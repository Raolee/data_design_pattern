낙관적 잠금 Optimistic Lock
===

왜 사용하는가?
---

> 수량이 정해진 아이템을 판매한다고 해보자.  
> 아이템은 정확한 수량만큼 판매되어야 하기에 수량은 정확해야 한다.  
> 가장 간단한 해결책은 판매를 할 때는 Lock 을 거는 방법이다.    
> Lock 이 걸려있다면 판매 요청을 실패시키거나 기다리게 해서 처리하면 된다.  
> 
> 하지만 판매가 급격하게 늘어나, 미리 판매할 수 있는 수량이 되는지 조회하는 경우가 급격히 늘었다고 가정해보자.  
> 이때 가장 값싼 방식은 데이터 사본을 가지고 있는 방법이다.  
> 하지만, 재고 수량과 잠금 여부는 데이터 사본이 아니라 원장이 가지고 있기 때문에 데이터 사본의 의미가 사라진다.

기존 잠금 방식의 장점은 명백해서 굳이 적지 않고 단점은 무엇이 있을까?
* Lock/Unlock 에 대한 명시적인 오퍼레이션이 추가 된다.
  * 한 개의 row 에 3번의 write 가 필요
* 광범위하게 적용하면 시스템 확장성이 떨어진다.
  * 무지성 잠금은 전체 성능을 떨어뜨린다.
* 예시와 같은 극한적 상황에서 조회까지 잠금에 걸려버린다.

잠금 방식의 단점을 해결하기 위해  
쓰기(lock, unlock) 대신 조회 비용을 조금 더 높여 잠금을 걸지 않는 방식이 낙관적 잠금 Optimistic lock 이다.

구체적으로 낙관적 잠금을 어떻게 하는데?
---
낙관적 잠금은 원장과 사본 사이의 차이를 알 수 있는 값을 통해서,
사본이 최신이 아니라는 점을 확인하는 잠금 방법을 택한다.
* 데이터에 최신 변경 시간을 기록한다.
* 데이터에 버전 정보를 기록한다.

이렇게 하면 사본으로 데이터를 조회한 후 진행시키다가 원장에 쓰려고 할 때  
원장과 시간이 다르거나 버전이 다르면 실패시키는 방식으로 진행한다.

위의 예시를 낙관적 잠금으로 바꾸면 아래와 같다.
> 아이템 123의 수량이 1개 남았다고 원장에 저장되어 있고 버전정보는 100이다. 
> 복제본에도 1개라고 저장되어 있고 버전정보는 100이다.  
> A는 판매자 인데 복제본에서 수량을 조회했더니 판매할 수량이 1개 남았음을 확인하다. 물론 버전정보 100도 확인했다.   
> A는 판매 절차를 마치고 수량을 감소 시키기 위해 아래와 같은 write operation 을 날린다.    
> ```
> update table_name
> set quantity = quantity - 1, version = version + 1
> where item_id = 123 and version = 100
> ```
> 이렇게 A는 update 성공을 받았고 원장에는 수량이 0이 정상적으로 반영된다.    
> 하지만 아직 복제본 반영이 되지 않았다고 가정하자.  
> 이때 판매자 B가 복제본에서 아이템 123의 수량을 조회했다.   
> 복제본이 반영되지 않았기에 B는 수량 1개와 버전정보 100을 확인했다.  
> B도 판매 절차를 마치고 A와 동일한 write operation 을 날리는데 실패한다.  
> 이미 원장에는 version 정보가 달라져 있기 때문이고 B는 이를 인지할 수 있다.

사실 낙관적 잠금은 잠금이라는 행위가 없어서 잠금이라 부르기 약간 애매한 구석이 있다.  
어떤 Storage 를 쓰느냐에 따라 낙관적 잠금의 구현이 불가능할 수도 있다.  
그래서 낙관적 잠금에서 필요한 사항을 보면 대략 아래의 조건들이 있다.

* 데이터를 Create/Update 할 때 변경시간이나 버전정보를 함께 포함하여 저장할 수 있어야 한다.
* 데이터의 복제(replica)를 지원해야 한다.
* 데이터를 Update 할 때 변경시간이나 버전정보를 조건으로 넣을 수 있어야 한다.

낙관적 잠금의 장단점을 정리해보면?
---
장점
* 복제본을 항상 최신이라 가정하며 읽고, 원장을 백그라운드로 읽어내면 클라이언트 관점에서 데이터 최신 여부를 확인할 수 있다.
* 물리적인 잠금이 없다.
* 잠금 상태로 남을 가능성이 없다. (낙관적 잠금만 사용한다면)

단점
* 원장에 쓰려고 할 때 실패 여부를 알기 때문에, 트랜잭션의 프로세스가 길면 다시 시작하는 비용이 크다.
* 일관성을 맞추기 위해 낙관적 잠금을 이용하지 않아버릴 수 있다. (휴먼 이슈)

낙관적 잠금의 전략
---
타임스탬프는 사실 문제점이 있다. 정말 빠른시간안에 처리된다면 타임스탬프가 겹쳐버릴 수 있기 때문.  
그래서 버전정보나 다른 방법을 택하는 것이 좋다.
* 버전 정보 : 0이나 1부터 시작해서, write operation 때 마다 1씩 증가 시킨다.
* 그외 : 아예 항상 변경되는 다른 컬럼의 값을 버전처럼 사용하는 것이다. (where 절에 다른 column 의 조건들을 같이 넣어버림)

낙관적 잠금의 한계
---
전체 작업 단위에 이르는 트랜잭션에서는 사실상 사용하기 어렵다.  
논리적인 작업 단위의 갱신 연산만 사용하는 경우가 이득을 볼 수 있다.