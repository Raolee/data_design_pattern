낙관적 잠금 Optimistic Lock
===

왜 사용하는가?
---

> 수량이 정해진 아이템을 판매하기 위해 서버 한 대를 운용한다고 가정해보자.  
> 아이템 판매는 수량만큼 판매되어야 하기 때문에 정확한 수량 체크가 중요하다.  
> 조회 시 판매할 수량이 있다면 요청이 들어올 수 있고, 이 요청은 동시에 들어올 수 있다.      
> 만약, 판매 수량이 1개 남은 상태인데 동시에 2 건 이상의 판매 요청이 온다면 어떻게 해야할까?  
>
> 가장 간단한 해결책은 서버가 한 대이니,  
> OS Lock 혹은 Application Lock 을 걸어서 동시 실행을 막는 것이다.  
> 하지만 판매 수량이 충분하다면 Lock 이 필요치 않으나 특정한 케이스인 '거의 다 판매되어 갈 때의 정합성'을 위해 모든 판매 때 Lock을 걸게 된다는 점이다.  
> 이는 명백하게 컴퓨팅 자원 낭비다.

OS/Application Lock 은 반드시 써야할 곳에 잘쓰면 정말 좋다.
Redis 는 Write 는 1개의 쓰레드가 담당하며, Etcd 도 쓰기를 줄 세운다.
그래도 무지성 적용 시 어떤 단점이 있을까?
* Lock/Unlock 에 대한 명시적인 오퍼레이션이 로직 곳곳에 추가 된다.
  * 개발자는 언제든지 Lock 을 빼먹을 실수를 하며, Unlock을 해주지 않을 때 deadlock이 발생한다. 
* 광범위하게 적용하면 시스템 확장성이 떨어진다.
  * 무지성 잠금은 아무리 서버를 늘려도 결국 1대가 처리하는 것 보다 못한 성능을 내게 만든다.
* '항상 최신의 데이터만 읽어야해!' 라는 극한적 조건을 달아버리면 조회까지 잠금에 묶이게 된다.

이러한 잠금 방식의 단점을 해결하기 위해
쓰기와 읽기 스토리지를 분리하고, '잠금' 대신 '조회 시점'과 '쓰기 시점'의 데이터를 비교해 처리를 완료하는 것을 낙관적 잠금 Optimistic lock 이라 한다.

그럼 구체적으로 낙관적 잠금을 어떻게 하는데?
---
낙관적 잠금은 원장을 복제하는 사본이 있는 상황을 전제한다.  
원장에 쓰기(생성/업데이트/삭제)가 성공하면 이후에야 사본에 이 데이터가 반영되는데    
확장적인 시스템은 많은 조회를 처리하기 위해 사본으로 조회를 일임하는 경우가 많다.

위 예시에 원장과 사본을 대입해보면 판매 수량은 사본을 통해 조회하게 되는데  
원장에 쓰려고 할 때, 내가 사본으로 보았던 데이터와 원본의 데이터가 차이가 발생하면 쓰기를 멈추게하여 동시적인 갱신을 막는 방법이다.  
다시 말해 낙관적 잠금은 원장에 쓰려고 할 때, 사본의 데이터와 차이가 있음을 알게 하는 방법으로 아래의 필드를 추가하여 알아낼 수 있다.  
* 데이터에 최신 변경 시간을 기록한다.
* 데이터에 버전 정보를 기록한다.

이렇게 하면 판매 수량을 사본에서 읽으면서 '최신 변경 시간'이나 '버전 정보'를 알게되고  
원장에 쓰려고 할 때 이 값을 조건으로 넣어 정확하게 일치 할 때만 쓰기를 성공시키는 것이다.

예시를 낙관적 잠금으로 만들었다면 아래와 같을 것이다.  
> 아이템 123의 남은 수량이 1개 라고 원장에 저장되어 있다. 이 정보는 사본도 동일하다.
> 이때 버전 정보는 100 이었다.
> 
> 판매자 A는 사본에서 수량 1개와 버전 정보 100을 확인하고, 1개를 판매하기 위한 비즈니스를 실행한다.
> A는 판매 비즈니스 절차가 진행되고 문제가 없어서 원본의 수량을 0으로 만들고자 한다.
> 해서 아래와 같은 write operation 을 요청한다. 
> ```
> update table_name
> set quantity = quantity - 1, version = version + 1
> where item_id = 123 and version = 100
> ```
> 원장은 변화가 없었기 때문에 A는 write operation 이 성공했다.
> 하지만 아직 사본에는 원장의 내용이 복사되지 않은 상태다.
> 
> 이때 판매자 B가 사본에서 남은 수량을 보니 1이었다.   
> 동일하게 판매 비즈니스를 진행하고 문제가 생기지 않아 write operation 을 수행한다.  
> 하지만, 버전 정보가 101로 바뀌었기 때문에 version 100의 write operation 은 실패한다.  
> B는 write 을 통한 effected count 가 0임 알 수 있기에 정합성이 맞지 않는 요청이었다는 것을 알 수 있다.

사실 낙관적 잠금은 잠금이라는 행위가 없다. 또한 어떤 Storage 를 쓰느냐에 따라 낙관적 잠금의 구현이 불가능할 수도 있다.  
낙관적 잠금을 하기 위해서는 Storage 에 필요한 요구 사항을 정리해보자면 아래와 같을 것이다.

* Atomic 연산이 가능해야 한다.
* Create/Update 연산을 수행할 때 데이터의 다른 field 를 increase 하거나 storage 의 시간을 기록할 수 있는 기능이 있어야 한다.
* 사본(replication) 을 지원하는 것이 좋다.
* Update/Delete 연산 시 ID 와 다른 조건을 함께 넣을 수 있어야 한다.

실제 사용해보고 공부해서 파악한 스토리지 중에 낙관적 잠금이 구현이 되는 것들은 아래와 같을 것이다.
`RDB, MongoDB, Etcd, Dynamodb, S3 등`이 있겠다.

낙관적 잠금의 장단점을 정리해보면?
---
장점
* 읽기는 사본, 쓰기는 원본 이라는 확장성을 가져갈 수 있다.
* 물리적인 잠금이 없다. => 데드락이 없다. 효율적이다. 등

단점
* 원장에 쓰려고 요청을 넣고 응답을 받아야지만 실패 여부를 알기 때문에 트랜잭션 수행이 길다면 롤백 비용이 커진다.
* 개발자가 놓친다면 낙관적 잠금을 이용하지 않아 일관성이 쉽게 깨질 수 있다.

낙관적 잠금의 전략
---
원본과 사본의 데이터 비교를 위한 타임스탬프는 문제점이 있다.  
정말 빠른시간 안에 처리된다면 타임스탬프가 겹쳐버릴 수 있기 때문이다. (ms 단위도 겹칠 가능성이 농후하다.)

그래서 버전정보나 아예 field(or column) 전체를 조건을 넣어서 수행할 수도 있다.
* 버전 정보 : 0이나 1부터 시작해서, write operation 때 마다 1씩 increase 시킨다.
* 그외 : write operation 때, 아예 다른 컬럼의 값들을 모조리 조건으로 넣어버린다.

낙관적 잠금의 한계
---
트랜잭션을 커밋/롤백하는 개념이 아니라서, 트랜잭션의 한 부분의 연산으로 사용한다면 의미가 없어진다.    
논리적인 작업 단위의 갱신 연산만 사용하는 경우가 이득을 볼 수 있다.