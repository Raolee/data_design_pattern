비관적 잠금 Pessimistic Lock
===

왜 사용하는가?
---
예시를 먼저 들어보도록 하겠다.
> 아이템은 아래의 정보를 가지고 있다고 가정해보자.  
> `아이템의 이름`  
> `아이템의 기본 속성 값`  
> `강화로 강해지는 아이템의 프로퍼티`  
> `아이템의 소유주 정보`  
>  
> 여기서 아이템은 또 거래소를 통해 판매할 수 있다고 가정을 추가해보겠다.
> 거래소는 `아이템의 소유주 정보` 를 바꾸게 되는데, 아이템의 판매가는 `강화로 강해지는 아이템의 프로퍼티` 에 달려있다고 가정해보겠다.  
> 따라서 아이템이 거래소에 매물로 등록되면 `강화` 를 하지 못하게 막아야 한다.
> 반면, 아이템의 `기본 속성 값`이 잘못되었거나 `아이템의 이름` 처럼 게임 차원에서 패치를 진행하는 경우는  
> 거래소에 등록이 되어있어도 변경이 가능해야 한다.
  
아이템 거래는 사실 `매우 긴 텀의 트랜잭션`이라 볼 수 있는데,    
OS/Application Lock 으로 커버할 수 없는 시간이 걸릴 것이다.  
거래소에 등록된 아이템은 `강화로 강해지는 아이템의 프로퍼티`를 변경할 수 없게 해야하는데  
나머지 `아이템의 이름`, `아이템의 기본 속성 값`은 변경할 수 있어야 한다.      
  
이 데이터의 특정 부분마다 `잠금` 상태를 기록하는 것  
다시 말해 어플리케이션 레벨에서 특정 데이터를 변경하기 위해 `진단 정보`를 넣는 것을 비관적 잠금 Pessimistic lock 이라고 한다.  

비관적 잠금의 구현은?
---

위의 예시를 기준으로 설명하자면  
`아이템의 이름`    
`아이템의 기본 속성 값`    
`강화로 강해지는 아이템의 프로퍼티`    
`아이템의 소유주 정보`  

마다 잠금 상태와 어떤 사유로 잠금이 걸렸는지를 기록한다.  
아마 아래와 같이 `잠금 여부`와 `잠금 사유`를 기록하게 될 것이다.  

`아이템의 이름` + `잠금 여부` + `잠금 사유`    
`아이템의 기본 속성 값` + `잠금 여부` + `잠금 사유`  
`강화로 강해지는 아이템의 프로퍼티` + `잠금 여부` + `잠금 사유`     
`아이템의 소유주 정보`+ `잠금 여부` + `잠금 사유`  

그리고 원본 레코드에 write operation 을 수행할 때   
잠금 여부와 잠금 사유를 같이 업데이트 한다.

비관적 잠금의 장단점은?
---
장점
* 어플리케이션은 다수의 클라이언트가 동일한 데이터를 편집하려는 상황을 발견할 수 있다.
* 긴 트랜잭션 텀을 가진 경우, 왜 진행이 불가능한지 `진단 정보`를 통해 더 자세히 알려줄 수 있다.
* 잠금 체계를 통해 비즈니스적인 의미 체계를 정의할 수 있게 된다. 다른 표현으로 아이템의 Status 를 잘 정의할 수 있게 될 것이다.

단점
* 역시나 개발자가 이를 따르지 않을 수 있다. `잠금 여부`와 `잠금 사유`를 갱신하지 않거나 확인하지 않는 개발이 언제든지 가능하다.
* 이를 통해 `잠금 상태` 로 지속해서 남아 `방치된 잠금 상태 orphan lock` 이 된다. 이를 해제할 명시적인 매커니즘이 없다.


비관적 잠금의 전략
---
레코드를 이루는 열마다 레코드를 전부 기록하면 동시성에 대한 심각한 제약을 겪는다.  
따라서 `잠금 상태`와 더불어 `누가`, `언제부터 언제까지`의 정보까지 추가로 더해 별도의 레코로 기록하는 것이 성능면에서 낫다.    
이를 이용하면 트랜잭션이 얼마나 오래걸렸는지 역산이 가능하다.  

`orphan lock` 을 정리하는 매커니즘이 필요하다. 이를 그대로 둔다면 영원히 잠겨있는 상태가 되며  
잠금 되어야 하는 시간을 정하고 길어진 경우 자동으로 잠금을 해제하는 타이머를 구현하거나,  
Batch process 로 주기적으로 이를 찾아 처리하는 것을 만들어도 된다.  

마지막으로는 아무래도 휴먼 에러를 줄이기 위한 방법이 될 텐데  
비관적 잠금을 가능하면 스토리지 안에서 해결이 되게 풀어내어 강제하도록 하는 것이 좋다.  
RDB, Mongodb 라면 Transaction 안에 `잠금 상태`를 꼭 조회하고 진행여부를 판단하게 강제한다.      
반면 Redis 나 Etcd 라면 Transaction Pipeline 이나 Txn 을 이용하여 read와 write 를 섞는 방법이 있을 것 같다. 